[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TidierIteration.jl",
    "section": "",
    "text": "TidierIteration.jl is a 100% Julia implementation of the purrr R package. It aims to ease the different ways to map (or apply) functions to Julia objects: arrays, dicts and so on. It also provides some tools of functional programming: adverbs, composition, safe-functions and more.\n\n\n\nFor the stable version:\n] add https://github.com/TidierOrg/TidierIteration\nThe ] character starts the Julia package manager. Press the backspace key to return to the Julia prompt.\nor\nusing Pkg\nPkg.add(url=\"https://github.com/TidierOrg/TidierIteration\")\n\n\n\nIn R purrr package, there are many ways to apply a function to each element of a set: the many map_ variants (map_lgl returns a vector of logicals, map_chr returns a vector of strings/characters, etc) and so on exist because the map function returns a list in R, which is a wild beast (R lists allow any kind of elements, and few functions are optimized (i.e. vectorized) on them as opposed to vectors). In comparison, R vectors are always of just one type (integers, booleans, etc.)\nIn Julia, arrays are already the most general structure in the sense that they can contain any kind of element. Arrays of just one type (say, integers) are still arrays. We don’t need the _lgl and _chr variants.\nBesides that, the name map is already taken in Julia and its arguments are fatally in the opposite order of the purrr map! Because of that, I decided to implement the apply function, which takes an iterable object x as the first argument and a function f as the second. So apply(x, f) means that for each element of x I want to apply the function f and return an array.\nSo, instead of defining a function like map_int in Julia, you can just type\napply(x, Int ∘ f)\nor, even better, let f return an integer.\n\n\nIn Julia we already have 3 ways to apply a function to each element of an array x, and they are very elegant ones:\nmap(f, x)\nor\n[f(xi) for xi ∈ x]\nor the one I prefer:\nf.(x)\n\n\n\n\nThe object x is always the first element of the apply family, so it’s easy to pipe them;\nWe extend the apply family to Julia objects which are not mapped by default, like dictionaries;\nWe also provide the apply2, iapply and papply methods to map over 2 or n elements at the same time;\nWe provide the flatten_* functions to tidy wild dictionaries (like JSON responses from APIs) and many adverbs.\n\n\n\n\n\nSee the documentation for examples.\n\n\napply, apply_keys, apply_dfc, apply_dfr, walk, apply2, walk2, iapply, iwalk, papply, pwalk;\n\n\n\nmodify, modify!, modify_if, modify_if!, keep, keep!, keep_keys, discard, discard!, compact, compact!;\n\n\n\nis_empty, is_non_empty, every, some, none, detect_index, detect, has_element, has_key, get_value;\n\n\n\ncompose, compose_n, negate, possibly;\n\n\n\nflatten, flatten_n, flatten_dfr, flatten_json, flatten_dfr_json, json_string, to_json;"
  },
  {
    "objectID": "index.html#what-is-tidieriteration.jl",
    "href": "index.html#what-is-tidieriteration.jl",
    "title": "TidierIteration.jl",
    "section": "",
    "text": "TidierIteration.jl is a 100% Julia implementation of the purrr R package. It aims to ease the different ways to map (or apply) functions to Julia objects: arrays, dicts and so on. It also provides some tools of functional programming: adverbs, composition, safe-functions and more."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "TidierIteration.jl",
    "section": "",
    "text": "For the stable version:\n] add https://github.com/TidierOrg/TidierIteration\nThe ] character starts the Julia package manager. Press the backspace key to return to the Julia prompt.\nor\nusing Pkg\nPkg.add(url=\"https://github.com/TidierOrg/TidierIteration\")"
  },
  {
    "objectID": "index.html#comparison-to-purrr",
    "href": "index.html#comparison-to-purrr",
    "title": "TidierIteration.jl",
    "section": "",
    "text": "In R purrr package, there are many ways to apply a function to each element of a set: the many map_ variants (map_lgl returns a vector of logicals, map_chr returns a vector of strings/characters, etc) and so on exist because the map function returns a list in R, which is a wild beast (R lists allow any kind of elements, and few functions are optimized (i.e. vectorized) on them as opposed to vectors). In comparison, R vectors are always of just one type (integers, booleans, etc.)\nIn Julia, arrays are already the most general structure in the sense that they can contain any kind of element. Arrays of just one type (say, integers) are still arrays. We don’t need the _lgl and _chr variants.\nBesides that, the name map is already taken in Julia and its arguments are fatally in the opposite order of the purrr map! Because of that, I decided to implement the apply function, which takes an iterable object x as the first argument and a function f as the second. So apply(x, f) means that for each element of x I want to apply the function f and return an array.\nSo, instead of defining a function like map_int in Julia, you can just type\napply(x, Int ∘ f)\nor, even better, let f return an integer.\n\n\nIn Julia we already have 3 ways to apply a function to each element of an array x, and they are very elegant ones:\nmap(f, x)\nor\n[f(xi) for xi ∈ x]\nor the one I prefer:\nf.(x)\n\n\n\n\nThe object x is always the first element of the apply family, so it’s easy to pipe them;\nWe extend the apply family to Julia objects which are not mapped by default, like dictionaries;\nWe also provide the apply2, iapply and papply methods to map over 2 or n elements at the same time;\nWe provide the flatten_* functions to tidy wild dictionaries (like JSON responses from APIs) and many adverbs."
  },
  {
    "objectID": "index.html#complete-list-of-implemented-functions",
    "href": "index.html#complete-list-of-implemented-functions",
    "title": "TidierIteration.jl",
    "section": "",
    "text": "See the documentation for examples.\n\n\napply, apply_keys, apply_dfc, apply_dfr, walk, apply2, walk2, iapply, iwalk, papply, pwalk;\n\n\n\nmodify, modify!, modify_if, modify_if!, keep, keep!, keep_keys, discard, discard!, compact, compact!;\n\n\n\nis_empty, is_non_empty, every, some, none, detect_index, detect, has_element, has_key, get_value;\n\n\n\ncompose, compose_n, negate, possibly;\n\n\n\nflatten, flatten_n, flatten_dfr, flatten_json, flatten_dfr_json, json_string, to_json;"
  },
  {
    "objectID": "reference/discard.html",
    "href": "reference/discard.html",
    "title": "discard",
    "section": "",
    "text": "discard\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndiscard(x, p)\n\nDiscard the elements x_i of collection x such that p(x_i) is true.",
    "crumbs": [
      "Reference",
      "discard"
    ]
  },
  {
    "objectID": "reference/modify_if.html",
    "href": "reference/modify_if.html",
    "title": "modify_if",
    "section": "",
    "text": "modify_if\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nmodify_if(x, f, p)\n\nModify a copy of x applying f to each of its elements where the function p is true.",
    "crumbs": [
      "Reference",
      "modify_if"
    ]
  },
  {
    "objectID": "reference/modify.html",
    "href": "reference/modify.html",
    "title": "modify",
    "section": "",
    "text": "modify\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nmodify(x, f)\n\nModify a copy of x applying f to each of its elements.",
    "crumbs": [
      "Reference",
      "modify"
    ]
  },
  {
    "objectID": "reference/keep!.html",
    "href": "reference/keep!.html",
    "title": "keep!",
    "section": "",
    "text": "keep!\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nkeep!(x, p)\n\nKeep the elements x_i of collection x such that p(x_i) is true.",
    "crumbs": [
      "Reference",
      "keep!"
    ]
  },
  {
    "objectID": "reference/discard!.html",
    "href": "reference/discard!.html",
    "title": "discard!",
    "section": "",
    "text": "discard!\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndiscard!(x, p)\n\nDiscard the elements x_i of collection x such that p(x_i) is true.",
    "crumbs": [
      "Reference",
      "discard!"
    ]
  },
  {
    "objectID": "reference/detect_index.html",
    "href": "reference/detect_index.html",
    "title": "detect_index",
    "section": "",
    "text": "detect_index\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndetect_index(x, p)\n\nReturns the index for the first element of x where p is true.",
    "crumbs": [
      "Reference",
      "detect_index"
    ]
  },
  {
    "objectID": "reference/is_non_empty.html",
    "href": "reference/is_non_empty.html",
    "title": "is_non_empty",
    "section": "",
    "text": "is_non_empty\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nis_non_empty(x)\n\nCheck if a object has length greater than 0.",
    "crumbs": [
      "Reference",
      "is_non_empty"
    ]
  },
  {
    "objectID": "reference/modify!.html",
    "href": "reference/modify!.html",
    "title": "modify!",
    "section": "",
    "text": "modify!\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nmodify!(x, f)\n\nModify x applying f to each of its elements.",
    "crumbs": [
      "Reference",
      "modify!"
    ]
  },
  {
    "objectID": "reference/none.html",
    "href": "reference/none.html",
    "title": "none",
    "section": "",
    "text": "none\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nnone(x, p)\n\nDo none x_i in x satisfies p?",
    "crumbs": [
      "Reference",
      "none"
    ]
  },
  {
    "objectID": "reference/some.html",
    "href": "reference/some.html",
    "title": "some",
    "section": "",
    "text": "some\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsome(x, p)\n\nDo some x_i in x satisfies p?",
    "crumbs": [
      "Reference",
      "some"
    ]
  },
  {
    "objectID": "reference/every.html",
    "href": "reference/every.html",
    "title": "every",
    "section": "",
    "text": "every\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nevery(x, p)\n\nDo every x_i in x satisfies p?",
    "crumbs": [
      "Reference",
      "every"
    ]
  },
  {
    "objectID": "reference/papply.html",
    "href": "reference/papply.html",
    "title": "papply",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\npapply(x, f)\n\nApply the function f to each element of x. This is a generalization of apply2.\n\n\n\nx: an iterable collection.\nf: a function with as many variables as there are elements in x.",
    "crumbs": [
      "Reference",
      "papply"
    ]
  },
  {
    "objectID": "reference/papply.html#arguments",
    "href": "reference/papply.html#arguments",
    "title": "papply",
    "section": "",
    "text": "x: an iterable collection.\nf: a function with as many variables as there are elements in x.",
    "crumbs": [
      "Reference",
      "papply"
    ]
  },
  {
    "objectID": "reference/apply_keys.html",
    "href": "reference/apply_keys.html",
    "title": "apply_keys",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\napply_keys(d::Dict, f)\n\nApply the function f to each key of d and return a dictionary with the same values of d.\n\n\n\nd: a dictionary.\nf: a function.",
    "crumbs": [
      "Reference",
      "apply_keys"
    ]
  },
  {
    "objectID": "reference/apply_keys.html#arguments",
    "href": "reference/apply_keys.html#arguments",
    "title": "apply_keys",
    "section": "",
    "text": "d: a dictionary.\nf: a function.",
    "crumbs": [
      "Reference",
      "apply_keys"
    ]
  },
  {
    "objectID": "reference/walk.html",
    "href": "reference/walk.html",
    "title": "walk",
    "section": "",
    "text": "walk\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nwalk(x, f)\n\nThe same as apply(x, f) but returns nothing.",
    "crumbs": [
      "Reference",
      "walk"
    ]
  },
  {
    "objectID": "reference/iapply.html",
    "href": "reference/iapply.html",
    "title": "iapply",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\niapply(x, f)\n\nApply the function f to each pair (i, x_i) for i in the index set of x.\n\n\n\nx: an iterable collection.\nf: a two-variable function.\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\niapply(d::Dict, f)\n\nApply the function f to each pair (k, d[k]) for k in the values-set of d.\n\n\n\nd: a dictionary.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "iapply"
    ]
  },
  {
    "objectID": "reference/iapply.html#arguments",
    "href": "reference/iapply.html#arguments",
    "title": "iapply",
    "section": "",
    "text": "x: an iterable collection.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "iapply"
    ]
  },
  {
    "objectID": "reference/iapply.html#arguments-1",
    "href": "reference/iapply.html#arguments-1",
    "title": "iapply",
    "section": "",
    "text": "d: a dictionary.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "iapply"
    ]
  },
  {
    "objectID": "reference/keep.html",
    "href": "reference/keep.html",
    "title": "keep",
    "section": "",
    "text": "keep\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nkeep(x, p)\n\nKeep the elements x_i of collection x such that p(x_i) is true.",
    "crumbs": [
      "Reference",
      "keep"
    ]
  },
  {
    "objectID": "reference/apply2.html",
    "href": "reference/apply2.html",
    "title": "apply2",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\napply2(x, y, f)\n\nApply the 2-variable function f to each element pair (x_i, y_i) where x_i (resp. y_i) is the i-th element of x (resp. y).\n\n\n\nx: an iterable collection.\ny: an iterable collection.\nf: a two-variable function.\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\napply2(d1::Dict, d2::Dict, f)\n\nThe same as Dict(k =&gt; f(d1[k], d2[k]) for k ∈ keys(d1) ∩ keys(d2)), that is: we apply f on (d1[k], d2[k]) for every k common key between d1 and d2.\n\n\n\nd1: a dictionary.\nd2: a dictionary.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "apply2"
    ]
  },
  {
    "objectID": "reference/apply2.html#arguments",
    "href": "reference/apply2.html#arguments",
    "title": "apply2",
    "section": "",
    "text": "x: an iterable collection.\ny: an iterable collection.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "apply2"
    ]
  },
  {
    "objectID": "reference/apply2.html#arguments-1",
    "href": "reference/apply2.html#arguments-1",
    "title": "apply2",
    "section": "",
    "text": "d1: a dictionary.\nd2: a dictionary.\nf: a two-variable function.",
    "crumbs": [
      "Reference",
      "apply2"
    ]
  },
  {
    "objectID": "reference/flatten_dfr.html",
    "href": "reference/flatten_dfr.html",
    "title": "flatten_dfr",
    "section": "",
    "text": "flatten_dfr\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nflatten_dfr(dicts::Vector{&lt;:Dict}, n::Int = 1)\n\nGiven a vector of dictionaries, flatten each of them and concatenate on a dataframe.",
    "crumbs": [
      "Reference",
      "flatten_dfr"
    ]
  },
  {
    "objectID": "reference/compact.html",
    "href": "reference/compact.html",
    "title": "compact",
    "section": "",
    "text": "compact\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompact(x)\n\nKeep the elements x_i of collection x such that is_non_empty(x_i) is true.",
    "crumbs": [
      "Reference",
      "compact"
    ]
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference",
    "section": "",
    "text": "Reference\nWrite your references here.",
    "crumbs": [
      "Reference"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nDescribe your tutorials here.",
    "crumbs": [
      "Tutorials"
    ]
  },
  {
    "objectID": "tutorials/tutorial-01.html",
    "href": "tutorials/tutorial-01.html",
    "title": "First tutorial",
    "section": "",
    "text": "First tutorial\nThis is my first tutorial!",
    "crumbs": [
      "Tutorials",
      "First tutorial"
    ]
  },
  {
    "objectID": "reference/modify_if!.html",
    "href": "reference/modify_if!.html",
    "title": "modify_if!",
    "section": "",
    "text": "modify_if!\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nmodify_if!(x, f, p)\n\nModify x applying f to each of its elements where the function p is true.",
    "crumbs": [
      "Reference",
      "modify_if!"
    ]
  },
  {
    "objectID": "reference/is_empty.html",
    "href": "reference/is_empty.html",
    "title": "is_empty",
    "section": "",
    "text": "is_empty\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nis_empty(x)\n\nCheck if a object has length 0.",
    "crumbs": [
      "Reference",
      "is_empty"
    ]
  },
  {
    "objectID": "reference/json_string.html",
    "href": "reference/json_string.html",
    "title": "json_string",
    "section": "",
    "text": "json_string\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\njson_string(x)\n\nConvert x to a JSON string.",
    "crumbs": [
      "Reference",
      "json_string"
    ]
  },
  {
    "objectID": "reference/has_key.html",
    "href": "reference/has_key.html",
    "title": "has_key",
    "section": "",
    "text": "has_key\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nhas_key(d, k)\n\nReturns true if the dictionary d has key k.",
    "crumbs": [
      "Reference",
      "has_key"
    ]
  },
  {
    "objectID": "reference/apply_dfr.html",
    "href": "reference/apply_dfr.html",
    "title": "apply_dfr",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\napply_dfr(x, f)\n\nApply the function f to each element of x and bind all the rows into a dataframe.\n\n\n\nx: an iterable collection.\nf: a function that returns a DataFrame.",
    "crumbs": [
      "Reference",
      "apply_dfr"
    ]
  },
  {
    "objectID": "reference/apply_dfr.html#arguments",
    "href": "reference/apply_dfr.html#arguments",
    "title": "apply_dfr",
    "section": "",
    "text": "x: an iterable collection.\nf: a function that returns a DataFrame.",
    "crumbs": [
      "Reference",
      "apply_dfr"
    ]
  },
  {
    "objectID": "reference/flatten_dfr_json.html",
    "href": "reference/flatten_dfr_json.html",
    "title": "flatten_dfr_json",
    "section": "",
    "text": "flatten_dfr_json\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nflatten_dfr_json(dicts::Vector{&lt;:Dict}, n::Int = 1)\n\nGiven a vector of dictionaries, flatten each of them and concatenate on a dataframe; remaining vectors and dictionaries are converted to a json string.",
    "crumbs": [
      "Reference",
      "flatten_dfr_json"
    ]
  },
  {
    "objectID": "reference/compose_n.html",
    "href": "reference/compose_n.html",
    "title": "compose_n",
    "section": "",
    "text": "compose_n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompose_n(f, n = 2)\n\nCompose the function f with itself n times.",
    "crumbs": [
      "Reference",
      "compose_n"
    ]
  },
  {
    "objectID": "reference/walk2.html",
    "href": "reference/walk2.html",
    "title": "walk2",
    "section": "",
    "text": "walk2\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nwalk2(x, y, f)\n\nThe same as apply2(x, y, f) but returns nothing.",
    "crumbs": [
      "Reference",
      "walk2"
    ]
  },
  {
    "objectID": "reference/flatten.html",
    "href": "reference/flatten.html",
    "title": "flatten",
    "section": "",
    "text": "flatten\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nflatten_dict(key, value)\n\nTransform a pair key and value into a dictionary.\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nflatten_dict(key, value:: Dict{&lt;:Any, &lt;:Any})\n\nGiven a key and a value which is a dictionary, concatenate the key string to every other key of the dictionary value. A dictionary of dictionaries will become only a dictionary of values.\nThus, we are “flattening” the inner dictionaries.\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nflatten_dict(dict::Dict{&lt;:Any, &lt;:Any}, n = 1)\n\nRemove one layer of dictionaries of a dictionary.",
    "crumbs": [
      "Reference",
      "flatten"
    ]
  },
  {
    "objectID": "reference/apply.html",
    "href": "reference/apply.html",
    "title": "apply",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\napply(x, f)\n\nApply the function f to each element of x and return an array.\n\n\n\nx: an iterable collection.\nf: a function.\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\napply(d::Dict, f)\n\nApply the function f to each value of d and return a dictionary with the same keys of d.\n\n\n\nd: a dictionary.\nf: a function.",
    "crumbs": [
      "Reference",
      "apply"
    ]
  },
  {
    "objectID": "reference/apply.html#arguments",
    "href": "reference/apply.html#arguments",
    "title": "apply",
    "section": "",
    "text": "x: an iterable collection.\nf: a function.",
    "crumbs": [
      "Reference",
      "apply"
    ]
  },
  {
    "objectID": "reference/apply.html#arguments-1",
    "href": "reference/apply.html#arguments-1",
    "title": "apply",
    "section": "",
    "text": "d: a dictionary.\nf: a function.",
    "crumbs": [
      "Reference",
      "apply"
    ]
  },
  {
    "objectID": "reference/detect.html",
    "href": "reference/detect.html",
    "title": "detect",
    "section": "",
    "text": "detect\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndetect(x, p)\n\nReturns the first element of x where p is true.",
    "crumbs": [
      "Reference",
      "detect"
    ]
  },
  {
    "objectID": "reference/pwalk.html",
    "href": "reference/pwalk.html",
    "title": "pwalk",
    "section": "",
    "text": "pwalk\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\npwalk(x, f)\n\nThe same as papply(x, f) but returns nothing.",
    "crumbs": [
      "Reference",
      "pwalk"
    ]
  },
  {
    "objectID": "reference/has_element.html",
    "href": "reference/has_element.html",
    "title": "has_element",
    "section": "",
    "text": "has_element\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nhas_element(x, y)\n\nReturns true if y is an element of x.",
    "crumbs": [
      "Reference",
      "has_element"
    ]
  },
  {
    "objectID": "reference/iwalk.html",
    "href": "reference/iwalk.html",
    "title": "iwalk",
    "section": "",
    "text": "iwalk\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\niwalk(x, f)\n\nThe same as iapply(x, f) but returns nothing.",
    "crumbs": [
      "Reference",
      "iwalk"
    ]
  },
  {
    "objectID": "reference/possibly.html",
    "href": "reference/possibly.html",
    "title": "possibly",
    "section": "",
    "text": "possibly\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\npossibly(f, otherwise = nothing)\n\nCreate a modified version of the function f such that it returns otherwise when f(x) throws an error.",
    "crumbs": [
      "Reference",
      "possibly"
    ]
  },
  {
    "objectID": "reference/get_value.html",
    "href": "reference/get_value.html",
    "title": "get_value",
    "section": "",
    "text": "get_value\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nget_value(d, k, v = nothing)\n\nTry to get the value d[k], it it exists. Otherwise, return v.",
    "crumbs": [
      "Reference",
      "get_value"
    ]
  },
  {
    "objectID": "reference/negate.html",
    "href": "reference/negate.html",
    "title": "negate",
    "section": "",
    "text": "negate\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nnegate(f)\n\nReturn a function which is the negation of f.",
    "crumbs": [
      "Reference",
      "negate"
    ]
  },
  {
    "objectID": "reference/apply_dfc.html",
    "href": "reference/apply_dfc.html",
    "title": "apply_dfc",
    "section": "",
    "text": "docblock\n\n\n\n\n\n\napply_dfc(x, f)\n\nApply the function f to each element of x and bind all the columns into a dataframe.\n\n\n\nx: an iterable collection.\nf: a function that returns a DataFrame.",
    "crumbs": [
      "Reference",
      "apply_dfc"
    ]
  },
  {
    "objectID": "reference/apply_dfc.html#arguments",
    "href": "reference/apply_dfc.html#arguments",
    "title": "apply_dfc",
    "section": "",
    "text": "x: an iterable collection.\nf: a function that returns a DataFrame.",
    "crumbs": [
      "Reference",
      "apply_dfc"
    ]
  },
  {
    "objectID": "reference/compact!.html",
    "href": "reference/compact!.html",
    "title": "compact!",
    "section": "",
    "text": "compact!\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompact!(x)\n\nKeep the elements x_i of collection x such that is_non_empty(x_i) is true.",
    "crumbs": [
      "Reference",
      "compact!"
    ]
  },
  {
    "objectID": "reference/compose.html",
    "href": "reference/compose.html",
    "title": "compose",
    "section": "",
    "text": "compose\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompose(args...)\n\nCreate the composite function of the args....\ncompose(f1, f2)(x) is equal to f2(f1(x)).",
    "crumbs": [
      "Reference",
      "compose"
    ]
  }
]